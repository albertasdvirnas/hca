% Formerly CBT.Hca.Settings.set_fast_sets
%
%
%
timeFramesNr = 0; % 0 - take all timeframes
alignMethod = 1; % 1 - nralign, 2 - ssdalign, 3 - ssg
genConsensus = 0; % generate consensus

adddefaulttheorysets = 0;
  
skipEdgeDetection = 0; % skip edge detection
edgeSettings = 1;
skipDoubleTanhAdjustment = 1;
comparisonMethod = 'dual_label'; % method for comparison of exp vs theory, alt 'unmasked_pcc_corr', 'mass_pcc', 'mp', and less tested onces, such as 'spearman'..
w = 200; %
displayResults = 1;
saveinfoscores = 1; % if to save infoscores

skipPrechoice = 1;
prestretchMethod = 0; % 0 - do not prestretch % 1 - prestretch to common length
theories = 'theories_2021-02-08_14_46_44_.txt'; % theories either as mat or directly txts
% theories = 'theories_2020-11-27_21_33_46_.txt'; % theories either as mat or directly txts
sparseTheories = 'theories_2020-11-27_21_34_39_.txt'; % theories either as mat or directly txts

userDefinedSeqCushion = 50;

[subfragment]
askForSubfragmentSettings = 1; % whether to ask for subfragment settings (to be implemented)
generate = 1; % whether to generate subfragments
numberFragments = 4; % how many subfragments to generate
%randomPosition = 1; % if position should be random
%fragmentLength = 200; % otherwise splits the length of barcode into totalLength/numberFragments

[filterSettings]
filter = 0; % filter
% filter settings. For one timeframe, refer to P.Torche paper for best
filterMethod = 0; % 0 - filter after stretching, 1 - before
filterSize = 1.4;
  
[kymosets]
askforkymos = 1; % sould we ask for kymos  
% sample filename, comment out for the release version
kymoFile = 'kymos.txt'; % if file with kymograph txt's was generated before, this is the name of the folder
sparseFile = 'kymossparse.txt'; % txt file with sparse barcodes
sparseMap = 1; % if sparseMap=1, then the dot barcode is already convolved with PSF
% all the different setting choices
askforsets = 1; % should we ask for settings

[random]
generate = 0; % generate random
noOfCutouts = 2; % number of random cutouts from the input set
cutoutSize = 200; % size of region to be cut out (units: pixels)

% bitmask settings
[bitmasking]
prestretchPixelWidth_nm = 108.33; % camera nm/px
psfSigmaWidth_nm = 200; % psf in nanometers
deltaCut = 3; % how many delta's should we take
%untrustedPx = sets.bitmasking.deltaCut*sets.bitmasking.psfSigmaWidth_nm/sets.bitmasking.prestretchPixelWidth_nm;

[consensus]
barcodeNormalization = 'bgmean';
promptForBarcodeClusterLimit = 1;
threshold = 0.75;

% import OptMap.MoleculeDetection.EdgeDetection.get_default_edge_detection_settings;
%  sets.edgeDetectionSettings = get_default_edge_detection_settings(sets.skipDoubleTanhAdjustment);

[export]
savetxt = 1;

[theory]
askfortheory = 0;
precision = 5;  %default is 5;
askfornmbp = 0;
psfSigmaWidth_nm = 200;
pixelWidth_nm = 108.33;
nmbp = 0.32;
skipStretch = 1;
stretchFactors = 1.05:0.01:1.15;

[duallabel]
scoreFolder = 'D:\Arkivet\DNAdev\hca\files\randomScores\';
fastaFolder = 'D:\Arkivet\DNAdev\hca\files\randomFasta\';
paramFolder = 'D:\Arkivet\DNAdev\hca\files\';
denseBarcodeType = 'ecodam';
sparsePattern = 'CTTAAG';
numPxMatchDiff = 50;
doBitmask = true;

[pvalue];    
file = '';
promtforparams = 0;
len2 = 5000000;
lenMin = 100;
lenMax = 1000;
numRnd = 1000;
pattern = 'GATC';
lenLong = 106666.6666666667;
lenShort = 1000;
stretchMax = 0;
barcodeType = 'dots'; % cb, dots, ecodam
variableType = 'lenLong'; % lenLong, lenShort, stretchMax, psf
varMin = 106666.6666666667;
varStep = 106666.6666666667;
varMax = 5000e6;
cbRandomizationMethod = 'randn'; % phaseRandomization, hybrid, randn, sample, randg
    
[output]
matDirpath = ''
askforoutputdir = 1;

